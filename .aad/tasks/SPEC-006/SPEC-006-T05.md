# SPEC-006-T05: キーボードイベント処理実装

## 基本情報

| 項目 | 内容 |
|------|------|
| タスクID | SPEC-006-T05 |
| SPEC | SPEC-006 |
| 複雑度 | M（4-8時間） |
| 優先度 | Must |
| 依存 | T04 |
| 担当 | 未アサイン |

---

## 概要

キーボード操作（`q`: 終了、`Tab`: View切り替え、`↑↓`: リスト選択、`Enter`: 詳細画面遷移、`Esc`: 戻る）を実装する。

---

## 作業内容

### 1. events.rs の実装
`src/events.rs`:
```rust
use crossterm::event::{self, Event, KeyCode, KeyEvent};
use anyhow::Result;
use std::time::Duration;

/// イベントハンドラ
pub struct EventHandler;

impl EventHandler {
    /// イベントを読み取る（タイムアウト付き）
    pub fn read_event(timeout: Duration) -> Result<Option<Event>> {
        if event::poll(timeout)? {
            Ok(Some(event::read()?))
        } else {
            Ok(None)
        }
    }

    /// キーイベントに変換
    pub fn as_key_event(event: Event) -> Option<KeyEvent> {
        match event {
            Event::Key(key_event) => Some(key_event),
            _ => None,
        }
    }
}
```

### 2. App::handle_event() の実装
`src/app.rs` を更新:
```rust
use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};

impl App {
    /// イベントを処理
    pub fn handle_event(&mut self, event: Event) -> Result<()> {
        if let Event::Key(key) = event {
            self.handle_key_event(key)?;
        }
        Ok(())
    }

    /// キーイベントを処理
    fn handle_key_event(&mut self, key: KeyEvent) -> Result<()> {
        match key.code {
            // 終了
            KeyCode::Char('q') | KeyCode::Char('Q') => {
                self.should_quit = true;
            }
            // Ctrl+C でも終了
            KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                self.should_quit = true;
            }
            // Tab: View切り替え
            KeyCode::Tab => {
                self.current_view = self.current_view.next();
            }
            // ↑: リスト選択（上）
            KeyCode::Up => {
                if self.selected_index > 0 {
                    self.selected_index -= 1;
                }
            }
            // ↓: リスト選択（下）
            KeyCode::Down => {
                self.selected_index += 1;
                // 上限チェックは実際のデータ量に応じて調整
            }
            // Enter: 詳細画面遷移
            KeyCode::Enter => {
                self.on_enter_pressed()?;
            }
            // Esc: 戻る
            KeyCode::Esc => {
                self.on_esc_pressed()?;
            }
            _ => {}
        }
        Ok(())
    }

    /// Enterキー押下時の処理
    fn on_enter_pressed(&mut self) -> Result<()> {
        match self.current_view {
            View::Dashboard | View::Monitor => {
                // 詳細画面に遷移
                self.previous_view = Some(self.current_view);
                self.current_view = View::Detail;
            }
            _ => {}
        }
        Ok(())
    }

    /// Escキー押下時の処理
    fn on_esc_pressed(&mut self) -> Result<()> {
        if let Some(prev) = self.previous_view {
            self.current_view = prev;
            self.previous_view = None;
        }
        Ok(())
    }
}
```

### 3. App構造体の更新
`previous_view` フィールドを追加:
```rust
pub struct App {
    current_view: View,
    previous_view: Option<View>,
    selected_index: usize,
    should_quit: bool,
}

impl App {
    pub fn new() -> Self {
        Self {
            current_view: View::Dashboard,
            previous_view: None,
            selected_index: 0,
            should_quit: false,
        }
    }
}
```

### 4. ユニットテストの追加
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};

    #[test]
    fn test_quit_on_q_key() {
        let mut app = App::new();
        let event = Event::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
        app.handle_event(event).unwrap();
        assert!(app.should_quit);
    }

    #[test]
    fn test_view_switch_on_tab() {
        let mut app = App::new();
        assert_eq!(app.current_view, View::Dashboard);

        let event = Event::Key(KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE));
        app.handle_event(event).unwrap();
        assert_eq!(app.current_view, View::Monitor);
    }

    #[test]
    fn test_list_navigation() {
        let mut app = App::new();
        assert_eq!(app.selected_index, 0);

        let down = Event::Key(KeyEvent::new(KeyCode::Down, KeyModifiers::NONE));
        app.handle_event(down).unwrap();
        assert_eq!(app.selected_index, 1);

        let up = Event::Key(KeyEvent::new(KeyCode::Up, KeyModifiers::NONE));
        app.handle_event(up).unwrap();
        assert_eq!(app.selected_index, 0);
    }
}
```

---

## 変更ファイル

- `crates/tui/src/events.rs` - イベントハンドラ実装
- `crates/tui/src/app.rs` - キーイベント処理追加

---

## 受け入れ基準

### AC-5.1: `tui/src/events.rs` にイベントハンドラが実装されている
```bash
test -f crates/tui/src/events.rs
```

### AC-5.2: `q` キーで終了できる
```bash
grep "KeyCode::Char('q')" crates/tui/src/app.rs
```

### AC-5.3: `Tab` キーで View が切り替わる
```bash
grep "KeyCode::Tab" crates/tui/src/app.rs
```

### AC-5.4: `↑` `↓` キーでリストが選択できる
```bash
grep "KeyCode::Up" crates/tui/src/app.rs
grep "KeyCode::Down" crates/tui/src/app.rs
```

### AC-5.5: `Enter` キーで詳細画面に遷移できる
```bash
grep "KeyCode::Enter" crates/tui/src/app.rs
```

### AC-5.6: `Esc` キーで前の画面に戻れる
```bash
grep "KeyCode::Esc" crates/tui/src/app.rs
```

---

## テストコマンド

```bash
# ユニットテスト実行
cargo test -p tui

# ビルド確認
cargo build -p tui

# Lintチェック
cargo clippy -p tui -- -D warnings
```

---

## 期待結果

| チェック項目 | 期待結果 |
|-------------|----------|
| イベント処理 | 全キー操作が実装されている |
| テスト | 全テスト成功 |
| ビルド | エラーゼロ |

---

## 備考

- Ctrl+C でも終了できるようにする
- リスト選択の上限チェックは実際のデータ量に応じて調整
- previous_view を追加してEscキーでの戻る機能を実装
